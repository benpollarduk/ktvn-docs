{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Ktvn is a library that provides a framework for building visual novels in Kotlin or Java.</p> <p>The repo is open source and is available at https://github.com/benpollarduk/ktvn.</p> <p>This documentation site is a work in progress, if there are any topics that aren't covered that you would like to see included, or if you spot any mistakes please report them on the Issues page on GitHub.</p>"},{"location":"api-documentation/","title":"Api Documentation","text":"<p>Please visit https://benpollarduk.github.io/ktvn-api-docs/ to view the Api documentation for Ktvn.</p>"},{"location":"audio/","title":"Audio","text":"<p>Ktvn supports audio to allow rich visual novels to be created. Audio is roughly broken in to two categories -  background music and sound effects.</p>"},{"location":"audio/#background-music","title":"Background Music","text":"<p>In Ktvn background music is specified as part of the Scene. This is documented on the Customising Scenes  page.</p>"},{"location":"audio/#sound-effects","title":"Sound Effects","text":"<p>Sounds effects can be played during any Step. All sound effects require a SoundEffectPlayer to play.</p>"},{"location":"audio/#soundeffectplayer","title":"SoundEffectPlayer","text":"<p>The SoundEffectPlayer is a class that invokes sound effects in Ktvn. It depends on an AudioAdapter. The  DynamicGameConfiguration provides an instance of AudioAdapter that is suitable for nearly all use cases.</p> <pre><code>val configuration = DynamicGameConfiguration()\nval audio = SoundEffectPlayer(configuration.gameAdapter.audioAdapter)\n</code></pre> <p>The SoundEffectPlayer can then be used to play sound effects with the sfx function. Here a next step is  used to play sfxWoosh.</p> <pre><code>next { audio sfx sfxWoosh }\n</code></pre> <p>In this case sfxWoosh is a ResourceSoundEffect, but a FileSoundEffect* could also be used.</p> <pre><code>val sfxWoosh = soundEffectFromResource(\"shuttleLaunch/audio/woosh.wav\")\n</code></pre>"},{"location":"customising-scenes/","title":"Customising Scenes","text":""},{"location":"customising-scenes/#overview","title":"Overview","text":"<p>A Scene is a section of a Chapter. It can be used to tell the story and describe what the player should see and  hear.</p>"},{"location":"customising-scenes/#setting-the-name","title":"Setting the name","text":"<p>A Scene has a name. This can be useful for referencing it and depending on the engine implementation may be  displayed when the scene is executed.</p> <pre><code>val scene = scene {\n    this name \"In the Mansion\"\n}\n</code></pre>"},{"location":"customising-scenes/#setting-the-background","title":"Setting the background","text":"<p>A Scene has a background. There a lots of ways backgrounds can be specified, and the Background interface adds  extensibility if required.</p> <p>Backgrounds can be specified from a path to a file.</p> <pre><code>val mansion = backgroundFromFile(\"mansion.jpg\")\nval scene = scene {\n    this background mansion\n}\n</code></pre> <p>Backgrounds can be specified from a resource key.</p> <pre><code>val mansion = backgroundFromResource(\"mansion.jpg\")\nval scene = scene {\n    this background mansion\n}\n</code></pre> <p>Simple solid color backgrounds can also be used.</p> <pre><code>val black = backgroundFromColor(Color.BLACK)\nval scene = scene {\n    this background black\n}\n</code></pre>"},{"location":"customising-scenes/#setting-the-music","title":"Setting the music","text":"<p>Each Scene can have background music.</p> <p>Audio can be specified from files.</p> <pre><code>val mansionTheme = trackFromFile(\"mansion.wav\")\nval scene = scene {\n    this music mansionTheme\n}\n</code></pre> <p>Audio can be specified from resources.</p> <pre><code>val mansionTheme = trackFromResource(\"mansion.wav\")\nval scene = scene {\n    this music mansionTheme\n}\n</code></pre> <p>And silence can be used when no music should play.</p> <pre><code>val scene = scene {\n    this music silence\n}\n</code></pre>"},{"location":"customising-scenes/#transitions","title":"Transitions","text":"<p>Transitions can be applied to a Scene. Transitions allow fade ins and fade outs etc. The SceneTransition  interface provides extensibility if required.</p> <p>Here a fade in from black over 250ms has been specified.</p> <pre><code>val scene = scene {\n    this transitionIn FadeIn(Color.BLACK, 250L)\n}\n</code></pre> <p>Here a fade out to black over 250ms has been specified.</p> <pre><code>val scene = scene {\n    this transitionOut FadeOut(Color.BLACK, 250L)\n}\n</code></pre>"},{"location":"customising-scenes/#layout","title":"Layout","text":"<p>Layout specifies how Characters are positioned for a scene, and how they move between positions.</p> <p>A layout must be created and configured so that it can interact with the GameEngine.</p> <pre><code>val configuration = DynamicGameConfiguration()\nval scene = scene {\n    this layout createLayout {\n        this configure configuration.gameAdapter.layoutAdapter\n    }\n}\n</code></pre> <p>The transition keyword specifies how characters should move around the layout. Here a Slide transition has been  specified with a duration of 100ms. The LayoutTransition interface adds extensibility if required.</p> <pre><code>val scene = scene {\n    this layout createLayout {\n        this transition Slide(100L)\n    }\n}\n</code></pre> <p>Characters can be added to a layout. In this example the character has been added to the left of the screen. The  character is not visible as it is off of the screen, but is ready to be pulled in to view when required.</p> <pre><code>val configuration = DynamicGameConfiguration()\nval ben = Character(\"Ben\", configuration.gameAdapter.characterAdapter)\nval scene = scene {\n    this layout createLayout {\n        this addLeftOf ben\n    }\n}\n</code></pre> <p>Characters can then move in a layout. The above examples can be combined to slide a character from the outside of the  left hand side of the screen to the center.</p> <pre><code>val configuration = DynamicGameConfiguration()\nval ben = Character(\"Ben\", configuration.gameAdapter.characterAdapter)\nval scene = scene {\n    this layout createLayout {\n        this configure configuration.gameAdapter.layoutAdapter\n        this transition Slide(100L)\n        this addLeftOf ben\n        this moveCenter ben\n    }\n}\n</code></pre>"},{"location":"game-engine/","title":"Game Engine","text":""},{"location":"game-engine/#overview","title":"Overview","text":"<p>The GameEngine is a critical part of Ktvn. Essentially, the GameEngine ties together a Game and the environment  it executes in. The GameEngine is responsible for managing game input and output. The GameEngine interface is so  important because it allows a VisualNovel to be written largely without a target platform in mind. Included in the Ktvn repo are a couple of examples of GameEngine implementations.</p>"},{"location":"game-engine/#ansiconsolegameengine","title":"AnsiConsoleGameEngine","text":"<p>Included in Ktvn is an example implementation of a GameEngine that targets an ANSI compatible console,  AnsiConsoleGameEngine. Running a visual novel in a basic terminal window with limited visuals seems pretty  counterproductive, but it is a clear way of demonstrating some aspects of implementing a GameEngine.</p>"},{"location":"game-engine/#debuggameengine","title":"DebugGameEngine","text":"<p>In app-ktvn-prototyper-swing there is an example implementation of a GameEngine that targets Swing. This is used in  the prototyper app. It's by no means intended as an engine to use in a production game, but serves the purpose of  demonstrating some of the visual features on Ktvn and is the engine that drives the prototyper app which can be used  for rough prototyping of games.</p>"},{"location":"game-engine/#implementing-a-custom-gameengine","title":"Implementing a custom GameEngine","text":"<p>It's important to understand the role of the GameEngine so that rich novels can be written that target any platform. In  this next section I'll describe how a GameEngine can be created to target a platform.</p>"},{"location":"game-engine/#creating-a-new-gameengine","title":"Creating a new GameEngine","text":"<p>Start by creating a class and inheriting the GameEngine interface.</p> <pre><code>package com.github.benpollarduk.ktvn.example.engine\n\nimport com.github.benpollarduk.ktvn.logic.engines.GameEngine\n\nclass ExampleEngine : GameEngine {\n}\n</code></pre> <p>Implement the interface to create stubs. We will discuss those in more detail in a bit.</p> <pre><code>package com.github.benpollarduk.ktvn.example.engine\n\nimport com.github.benpollarduk.ktvn.audio.SoundEffect\nimport com.github.benpollarduk.ktvn.audio.VolumeManager\nimport com.github.benpollarduk.ktvn.characters.Character\nimport com.github.benpollarduk.ktvn.characters.Emotion\nimport com.github.benpollarduk.ktvn.characters.Narrator\nimport com.github.benpollarduk.ktvn.characters.animations.Animation\nimport com.github.benpollarduk.ktvn.layout.Position\nimport com.github.benpollarduk.ktvn.layout.transitions.LayoutTransition\nimport com.github.benpollarduk.ktvn.logic.Answer\nimport com.github.benpollarduk.ktvn.logic.Flags\nimport com.github.benpollarduk.ktvn.logic.ProgressionController\nimport com.github.benpollarduk.ktvn.logic.Question\nimport com.github.benpollarduk.ktvn.logic.engines.GameEngine\nimport com.github.benpollarduk.ktvn.structure.*\nimport com.github.benpollarduk.ktvn.structure.transitions.SceneTransition\nimport com.github.benpollarduk.ktvn.text.log.Log\n\nclass ExampleEngine : GameEngine {\n    override val log: Log\n        get() = TODO(\"Not yet implemented\")\n    override val progressionController: ProgressionController\n        get() = TODO(\"Not yet implemented\")\n    override val volumeManager: VolumeManager\n        get() = TODO(\"Not yet implemented\")\n\n    override fun playSoundEffect(soundEffect: SoundEffect) {\n        TODO(\"Not yet implemented\")\n    }\n\n    override fun characterAsksQuestion(character: Character, question: Question) {\n        TODO(\"Not yet implemented\")\n    }\n\n    override fun narratorAsksQuestion(narrator: Narrator, question: Question) {\n        TODO(\"Not yet implemented\")\n    }\n\n    override fun getAnswerToQuestion(question: Question): Answer {\n        TODO(\"Not yet implemented\")\n    }\n\n    override fun characterSpeaks(character: Character, line: String) {\n        TODO(\"Not yet implemented\")\n    }\n\n    override fun characterThinks(character: Character, line: String) {\n        TODO(\"Not yet implemented\")\n    }\n\n    override fun characterShowsEmotion(character: Character, emotion: Emotion) {\n        TODO(\"Not yet implemented\")\n    }\n\n    override fun characterAnimation(character: Character, animation: Animation) {\n        TODO(\"Not yet implemented\")\n    }\n\n    override fun characterMoves(character: Character, from: Position, to: Position, transition: LayoutTransition) {\n        TODO(\"Not yet implemented\")\n    }\n\n    override fun narratorNarrates(narrator: Narrator, line: String) {\n        TODO(\"Not yet implemented\")\n    }\n\n    override fun enterStory(story: Story) {\n        TODO(\"Not yet implemented\")\n    }\n\n    override fun exitStory(story: Story) {\n        TODO(\"Not yet implemented\")\n    }\n\n    override fun enterChapter(chapter: Chapter, transition: ChapterTransition) {\n        TODO(\"Not yet implemented\")\n    }\n\n    override fun exitChapter(chapter: Chapter) {\n        TODO(\"Not yet implemented\")\n    }\n\n    override fun enterScene(scene: Scene, transition: SceneTransition) {\n        TODO(\"Not yet implemented\")\n    }\n\n    override fun exitScene(scene: Scene, transition: SceneTransition) {\n        TODO(\"Not yet implemented\")\n    }\n\n    override fun clearScene(scene: Scene) {\n        TODO(\"Not yet implemented\")\n    }\n\n    override fun enterStep(step: Step, flags: Flags, canSkip: Boolean, cancellationToken: CancellationToken) {\n        TODO(\"Not yet implemented\")\n    }\n\n    override fun exitStep(step: Step, flags: Flags) {\n        TODO(\"Not yet implemented\")\n    }\n}\n</code></pre> <p>Next set up the Log, ProgressionController and VolumeManager properties. These can just be instantiated  with default constructors.</p> <pre><code>override val log: Log = Log()\noverride val progressionController: ProgressionController = ProgressionController()\noverride val volumeManager: VolumeManager = VolumeManager()\n</code></pre> <p>The Log provides all logging for in game events so that users can review the story. If you use  DynamicGameConfiguration this will be automatically populated, but if you make your own GameConfiguration you  will need to populate the log yourself.</p> <p>The ProgressionController controls progression through the story. This allows you to access Auto and Skip  modes.</p> <p>The VolumeManager gives you a central point to manage all volumes for music, sound effects and other audio. The  VolumeManager does not directly control the system volume, it just provides a normalised value to represent the  relative volume that audio should be played at for each type of audio.</p> <p>Now it is just a case of writing some code for each stub. The stubs are described below.</p>"},{"location":"game-engine/#playsoundeffect","title":"playSoundEffect","text":"<p>Occurs when a sound effect should be played.</p>"},{"location":"game-engine/#characterasksquestion","title":"characterAsksQuestion","text":"<p>Occurs when a character asks a question.</p>"},{"location":"game-engine/#narratorasksquestion","title":"narratorAsksQuestion","text":"<p>Occurs when a narrator asks a question.</p>"},{"location":"game-engine/#getanswertoquestion","title":"getAnswerToQuestion","text":"<p>Occurs when an answer to a question should be determined.</p>"},{"location":"game-engine/#characterspeaks","title":"characterSpeaks","text":"<p>Occurs when a character speaks.</p>"},{"location":"game-engine/#characterthinks","title":"characterThinks","text":"<p>Occurs when a character thinks.</p>"},{"location":"game-engine/#charactershowsemotion","title":"characterShowsEmotion","text":"<p>Occurs when a character shows emotion.</p>"},{"location":"game-engine/#characteranimation","title":"characterAnimation","text":"<p>Occurs when a character starts an animation.</p>"},{"location":"game-engine/#charactermoves","title":"characterMoves","text":"<p>Occurs when a character moves between positions in a layout.</p>"},{"location":"game-engine/#narratornarrates","title":"narratorNarrates","text":"<p>Occurs when a narrator narrates.</p>"},{"location":"game-engine/#enterstory","title":"enterStory","text":"<p>Occurs when a story is entered.</p>"},{"location":"game-engine/#exitstory","title":"exitStory","text":"<p>Occurs when a story is exited.</p>"},{"location":"game-engine/#enterchapter","title":"enterChapter","text":"<p>Occurs when a chapter is entered.</p>"},{"location":"game-engine/#exitchapter","title":"exitChapter","text":"<p>Occurs when a chapter is exited.</p>"},{"location":"game-engine/#enterscene","title":"enterScene","text":"<p>Occurs when a scene is entered.</p>"},{"location":"game-engine/#exitscene","title":"exitScene","text":"<p>Occurs when a scene is exited.</p>"},{"location":"game-engine/#clearscene","title":"clearScene","text":"<p>Occurs when a scene should be cleared.</p>"},{"location":"game-engine/#enterstep","title":"enterStep","text":"<p>Occurs when a step is entered.</p>"},{"location":"game-engine/#exitstep","title":"exitStep","text":"<p>Occurs when a step is exited.</p>"},{"location":"game-engine/#applying-your-gameengine","title":"Applying your GameEngine","text":"<p>Don't forget to apply your engine to the GameConfiguration. Unless you have implemented your own  GameConfiguration this will likely be the DynamicGameConfiguration. After you have done this, you should be all set!</p> <pre><code>val configuration = DynamicGameConfiguration().also {\n    it.engine = YourEngine()\n}\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#adding-the-package-to-your-project","title":"Adding the package to your project","text":"<p>You need to pull Ktvn into your project. The easiest way to do this is to add the package. The latest package and  installation instructions are available here.</p>"},{"location":"getting-started/#first-visual-novel","title":"First Visual Novel","text":"<p>Once the package has been installed it's time to jump in and start building your first visual novel.</p>"},{"location":"getting-started/#setup","title":"Setup","text":"<p>To start with create a new Console application. It should look something like this:</p> <pre><code>package com.github.benpollarduk.ktvn.gettingstarted\n\nfun main(args: Array&lt;String&gt;) {\n\n}\n</code></pre>"},{"location":"getting-started/#adding-the-gameengine","title":"Adding the GameEngine","text":"<p>Every Ktvn game requires a GameEngine. The only engine currently included in the Ktvn core library is AnsiConsoleGameEngine. This engine allows a visual novel to be executed on an ANSI compatible console. </p> <pre><code>val engine = AnsiConsoleGameEngine()\n</code></pre>"},{"location":"getting-started/#adding-the-gameconfiguration","title":"Adding the GameConfiguration","text":"<p>Every Ktvn game requires a GameConfiguration. The configuration ties together many of the concepts required to  execute a game. For nearly all applications the DynamicGameConfiguration is a good match because it allows  properties to be specified after its instantiation. Let's add one in the main function and apply the engine.</p> <pre><code>val configuration = DynamicGameConfiguration().also {\n    it.engine = engine\n}\n</code></pre>"},{"location":"getting-started/#adding-a-character-and-a-narrator","title":"Adding a Character and a Narrator","text":"<p>All visual novels will require at least a Narrator or a Character to tell the story. Let's add one of each to  the main function, after the engine.</p> <pre><code>val ben = Character(\"Ben\", configuration.gameAdapter.characterAdapter)\n</code></pre> <p>Here I've added a character called Ben (of course) and specified that the adapter is provided by the configuration.  The adapter allows the Character to interact with the engine.</p> <p>Next I'll add a Narrator.</p> <pre><code>val narrator = Narrator(configuration.gameAdapter.narratorAdapter)\n</code></pre> <p>I've specified that the adapter is provided by the configuration. The adapter allows the Narrator to interact with  the engine. </p>"},{"location":"getting-started/#creating-a-basic-visual-novel-structure","title":"Creating a basic visual novel structure","text":"<p>The next thing to do is to add the structure of the novel itself. We can use the DSL to simplify the process. To start  with, let's add a story in the main function. The story will only contain a single chapter, which contains a single  scene.</p> <pre><code>val story = story {\n    this add chapter {\n        this add scene {\n\n        }\n    }\n}\n</code></pre> <p>Story, Chapter and Scene can all have a name, lets name the scene.</p> <pre><code>val story = story {\n    this add chapter {\n        this add scene {\n            this name \"Welcome to Ktvn\"\n        }\n    }\n}\n</code></pre> <p>Each scene that contains Characters should have a layout to help with the positioning of characters. The layout needs  to be configured so that the game engine can respond to character movements.</p> <pre><code>val story = story {\n    this add chapter {\n        this add scene {\n            this name \"Welcome to Ktvn\"\n            this layout createLayout {\n                this configure configuration.gameAdapter.layoutAdapter\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/#adding-some-steps","title":"Adding some steps","text":"<p>Each scene can contain one or more steps. Let's add a simple step to introduce the story.</p> <pre><code>val story = story {\n    this add chapter {\n        this add scene {\n            this name \"Welcome to Ktvn\"\n            this layout createLayout {\n                this configure configuration.gameAdapter.layoutAdapter\n            }\n            next { narrator narrates \"Welcome to the story!\" }\n        }\n    }\n}\n</code></pre> <p>Next, we could move the character in to view.</p> <pre><code>val story = story {\n    this add chapter {\n        this add scene {\n            this name \"Welcome to Ktvn\"\n            this layout createLayout {\n                this configure configuration.gameAdapter.layoutAdapter\n            }\n            next { narrator narrates \"Welcome to the story!\" }\n            next { layout moveLeft ben }\n        }\n    }\n}\n</code></pre> <p>And then we can make the character speak.</p> <pre><code>val story = story {\n    this add chapter {\n        this add scene {\n            this name \"Welcome to Ktvn\"\n            this layout createLayout {\n                this configure configuration.gameAdapter.layoutAdapter\n            }\n            next { narrator narrates \"Welcome to the story!\" }\n            next { layout moveLeft ben }\n            next { ben says \"Hi.\" }\n        }\n    }\n}\n</code></pre> <p>And then make the character smile.</p> <pre><code>val story = story {\n    this add chapter {\n        this add scene {\n            this name \"Welcome to Ktvn\"\n            this layout createLayout {\n                this configure configuration.gameAdapter.layoutAdapter\n            }\n            next { narrator narrates \"Welcome to the story!\" }\n            next { layout moveLeft ben }\n            next { ben says \"Hi.\" }\n            next { ben looks happy }\n        }\n    }\n}\n</code></pre> <p>There is much more that can be done, but this is a simple example just to get started.</p>"},{"location":"getting-started/#executing-the-game","title":"Executing the game","text":"<p>There is a small amount to do to make the story executable. First, it needs to be wrapped in to a VisualNovel. Then  a new Game needs to be made from the VisualNovel so that the story can be executed.</p> <pre><code>val novel = VisualNovel.create(story, configuration)\nval exampleGame = Game(novel)\n</code></pre> <p>The GameExecutor class can execute instances of Game. Games can be executed either synchronously or  asynchronously.</p> <pre><code>GameExecutor.executeAysnc(exampleGame)\n</code></pre> <p>A quirk of the AnsiConsoleEngine is that we need to start processing the input from the standard input to be able  to interact with the game. We will need to stop processing this input when the game execution ends. We will start  processing the input when the game begins and stop when execution finishes.</p> <pre><code>GameExecutor.executeAysnc(exampleGame) {\n        engine.endProcessingInput()\n    }\n\nengine.beginProcessingInput()\n</code></pre>"},{"location":"getting-started/#bringing-it-all-together","title":"Bringing it all together","text":"<p>That was a lot to go through, but results in only a small amount of code. It should look like this:</p> <pre><code>package com.github.benpollarduk.ktvn.getting.started\n\nimport com.github.benpollarduk.ktvn.characters.Character\nimport com.github.benpollarduk.ktvn.characters.Emotions.happy\nimport com.github.benpollarduk.ktvn.characters.Narrator\nimport com.github.benpollarduk.ktvn.layout.Layout\nimport com.github.benpollarduk.ktvn.layout.Layout.Companion.createLayout\nimport com.github.benpollarduk.ktvn.logic.Game\nimport com.github.benpollarduk.ktvn.logic.GameExecutor\nimport com.github.benpollarduk.ktvn.logic.VisualNovel\nimport com.github.benpollarduk.ktvn.logic.configuration.DynamicGameConfiguration\nimport com.github.benpollarduk.ktvn.logic.engines.ansiConsole.AnsiConsoleGameEngine\nimport com.github.benpollarduk.ktvn.structure.Chapter\nimport com.github.benpollarduk.ktvn.structure.Chapter.Companion.chapter\nimport com.github.benpollarduk.ktvn.structure.Scene\nimport com.github.benpollarduk.ktvn.structure.Scene.Companion.scene\nimport com.github.benpollarduk.ktvn.structure.Story\nimport com.github.benpollarduk.ktvn.structure.Story.Companion.story\nimport com.github.benpollarduk.ktvn.structure.steps.Then.Companion.next\n\nfun main(args: Array&lt;String&gt;) {\n    val engine = AnsiConsoleGameEngine()\n    val configuration = DynamicGameConfiguration().also {\n        it.engine = engine\n    }\n\n    val ben = Character(\"Ben\", configuration.gameAdapter.characterAdapter)\n    val narrator = Narrator(configuration.gameAdapter.narratorAdapter)\n\n    val story = story {\n        this add chapter {\n            this add scene {\n                this name \"Welcome to Ktvn\"\n                this layout createLayout {\n                    this configure configuration.gameAdapter.layoutAdapter\n                }\n                next { narrator narrates \"Welcome to the story!\" }\n                next { layout moveLeft ben }\n                next { ben says \"Hi.\" }\n                next { ben looks happy }\n            }\n        }\n    }\n\n    val novel = VisualNovel.create(story, configuration)\n    val exampleGame = Game(novel)\n\n    GameExecutor.executeAysnc(exampleGame) {\n        engine.endProcessingInput()\n    }\n\n    engine.beginProcessingInput()\n}\n</code></pre> <p>Simply build and run the application and congratulations, you have a working Ktvn visual novel!</p>"},{"location":"structure/","title":"Structure","text":"<p>A Ktvn visual novel starts with a Story. A Story contains one or more Chapters. Each Chapter contains one or more Scenes. Each Scene contains one or more Steps. There are several types of Step, and Step is extensible so that the DSL can be customised.</p> <pre><code>Story\n\u251c\u2500\u2500 Chapter\n\u2502   \u251c\u2500\u2500 Scene\n\u2502   |   \u251c\u2500\u2500 Step\n\u2502   |   \u251c\u2500\u2500 Step\n\u2502   |   \u251c\u2500\u2500 Step\n|   \u251c\u2500\u2500 Scene\n\u2502   |   \u251c\u2500\u2500 Step\n\u2502   |   \u251c\u2500\u2500 Step\n\u251c\u2500\u2500 Chapter\n\u2502   \u251c\u2500\u2500 Scene\n\u2502   |   \u251c\u2500\u2500 Step\n|   \u251c\u2500\u2500 Scene\n\u2502   |   \u251c\u2500\u2500 Step\n</code></pre> <p>This simple structure can be used to develop entire stories.</p>"},{"location":"using-resources/","title":"Resolving Resources","text":""},{"location":"using-resources/#overview","title":"Overview","text":"<p>A visual novel will likely include lots of images and audio. These can be added as resources. Ktvn attempts to simplify  the management of resources to reduce the burden on the developer as well as encouraging consistent practices and  conventions. Ktvn does this for characters through the CharacterResourceLookup that is present on each  VisualNovel.</p>"},{"location":"using-resources/#characterresourcelookup","title":"CharacterResourceLookup","text":"<p>A CharacterResourceLookup attempts to simplify the lookup process for resources related to a character. Each  character may have different emotions and variations that need to be displayed, and at some point these will need to be  resolved in to images for the GameEngine to render. The CharacterResourceLookup is an interface so you can  write your own implementations if you want to use this feature, but by default a LazyCharacterResourceLookup class  is provided.</p>"},{"location":"using-resources/#lazycharacterresourcelookup","title":"LazyCharacterResourceLookup","text":"<p>The LazyCharacterResourceLookup is the default CharacterResourceLookup. This provides a lookup for a character  image in a lazy manner. Essentially it registers keys for resources as they are requested. </p> <p>When instantiating the LazyCharacterResourceLookup you can provide it with a default path and an extension for  image types.</p> <pre><code>val characterResourceLookup: CharacterResourceLookup = LazyCharacterResourceLookup(\n    \"images/characters/\",\n    \".png\"\n)\n</code></pre> <p>This path should match the directory structure of your resources. For example the above path  \"my_visual_novel/images/characters/\" would match this directory structure:</p> <pre><code>My_Visual_Novel\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 main\n\u2502   |   \u251c\u2500\u2500 resources\n\u2502   |   |   \u251c\u2500\u2500 images\n\u2502   |   |   |   \u251c\u2500\u2500 characters\n</code></pre> <p>Inside that directory images for the characters can be added with names that match the pattern  {name}-{emotion}{extension}. If the character has a variation then the pattern  {name}-{variation}-{emotion}{extension} can be used. Case is not important.</p> <p>For example, when adding and image for a character using PNG files where the character is called Sophie who has an  unmodified emotion the following resource name should be used:</p> <pre><code>sophie-normal.png\n</code></pre> <p>The resource name for the image where she has the emotion happy:</p> <pre><code>sophie-happy.png\n</code></pre> <p>And a different variation of here looking happy, for example a version where she has aged:</p> <pre><code>sophie-future-happy.png\n</code></pre> <p>When the GameEngine needs to render the character, the correct image can be looked up through the VisualNovel  instance of CharacterResourceLookup:</p> <pre><code>val imageResourcePath = visualNovel.characterResourceLookup.getKey(character)\n</code></pre> <p>This method of lazy resource name assignment means that there is little burden on the developer to manage the resources  and there is a consistent approach applied when naming resources. However, if an explicit key needs to be used it can  be registered with the LazyCharacterResourceLookup:</p> <pre><code>val characterResourceLookup: CharacterResourceLookup = LazyCharacterResourceLookup(\n    \"images/characters/\",\n    \".png\"\n).also {\n    it.registerResource(character, \"my-resource-name.png\")\n}\n</code></pre>"},{"location":"dsl/choice/","title":"Choice","text":""},{"location":"dsl/choice/#overview","title":"Overview","text":"<p>Choice allows the user to present a question to the user and receive an answer.</p>"},{"location":"dsl/choice/#use","title":"Use","text":"<p>A character or the narrator can ask a multiple choice question.</p> <pre><code>choice {\n    morgana asks question {\n        this line \"Why we do, don't we dear?\"\n        this option answer {\n            this line \"Of course.\"\n            this does { flags -&gt;\n                flags setTrue \"Michel likes Morgana\"\n            }\n        }\n        this option answer {\n            this line \"I hate you!\"\n            this does { flags -&gt;\n                flags setTrue \"Michel hates Morgana\"\n            }\n        }\n    }\n}\n</code></pre> <p>Each choice can have multiple options. Each option has an optional script specified by the does keyword.  Notice the use of the flags class. A single instance of Flags exists for each game and can be used to pass values  between steps. Each flag has a string key and a boolean value. If a flag does not exist when it is read then false will  be returned as default. In this case a flag is set to register the option that the user picked.</p>"},{"location":"dsl/clear/","title":"Clear","text":""},{"location":"dsl/clear/#overview","title":"Overview","text":"<p>Clear is a step that signals that the current scene should be cleared. The engine is responsible for actioning this in  a way that makes sense for the executing game.</p>"},{"location":"dsl/clear/#use","title":"Use","text":"<p>Clear has no parameters and is presented as an empty block.</p> <pre><code>clear { }\n</code></pre> <p>Clear name be given a name if desired, which can be useful if it needs to be referenced from within a story.</p> <pre><code>clear {\n    this name \"Clear step\"\n}\n</code></pre> <p>Suggested use cases are for clearing the text from a narrative scene, or removing all dialog from a dialog scene.</p>"},{"location":"dsl/conditional/","title":"Conditional","text":""},{"location":"dsl/conditional/#overview","title":"Overview","text":"<p>Conditional allows a step to only be invoked if a specified condition is met.</p>"},{"location":"dsl/conditional/#use","title":"Use","text":"<p>The condition must be specified. If this case the flag \"Michel likes Morgana\" must be present and set true for  does block to be executed when the step is invoked. The returns keyword specifies how the scene should continue  when this step completes.</p> <pre><code>conditional {\n    this condition \"Michel likes Morgana\"\n    this does {\n        morgana looks amused\n        morgana says \"Fool, I despise you!\"\n    }\n    this returns Continue\n}\n</code></pre> <p>Conditional can be though of as a simple if statement.</p>"},{"location":"dsl/decision/","title":"Decision","text":""},{"location":"dsl/decision/#overview","title":"Overview","text":"<p>Decision is very similar to Choice, but allows the step to be named. This is useful if the story needs to jump to  this step, or if the step should be referenced from within the story for any other reason.</p>"},{"location":"dsl/decision/#use","title":"Use","text":"<p>The name keyword allows the decision step to be assigned a name. The does keyword specifies the code that  will be executed when the step is invoked.</p> <pre><code>decision {\n    this name \"Michel's feeling towards Morgana\"\n    this does {\n        morgana asks question {\n            this line \"Why we do, don't we dear?\"\n            this option answer {\n                this line \"Of course.\"\n                this does { flags -&gt;\n                    flags setTrue \"Michel likes Morgana\"\n                }\n            }\n            this option answer {\n                this line \"I hate you!\"\n                this does { flags -&gt;\n                    flags setTrue \"Michel hates Morgana\"\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Decision may be a more appropriate step to use than Choice in cases where the step itself should be referenced.</p>"},{"location":"dsl/end/","title":"End","text":""},{"location":"dsl/end/#overview","title":"Overview","text":"<p>End is a simple step that signifies that an ending has been reached.</p>"},{"location":"dsl/end/#use","title":"Use","text":"<p>The ending keyword specifies the Ending that has been reached.</p> <pre><code>end {\n    this ending Ending(\"True End.\", 1)\n}\n</code></pre> <p>There isn't a lot more to be said for Ending!</p>"},{"location":"dsl/interactive/","title":"Interactive","text":""},{"location":"dsl/interactive/#overview","title":"Overview","text":"<p>Interactive is a step that adds extensibility to the game in the form of allowing other components to be called. For  example, some visual novels may contain mini-games. Providing the mini game implements or is wrapped by  InteractiveComponent it can be invoked in a step.</p>"},{"location":"dsl/interactive/#use","title":"Use","text":"<p>The element keyword specifies the instance of Interactive that will be invoked. Any arguments can be provided  with the args keyword.</p> <pre><code>interactive {\n    this element component\n    this args arrayOf(\"args1\", \"args2\")\n}\n</code></pre> <p>Interactive itself if fairly shallow and all logic should be contained within the InteractiveComponent that  this step invokes.</p>"},{"location":"dsl/next/","title":"Next","text":""},{"location":"dsl/next/#overview","title":"Overview","text":"<p>Next is a simple step to allow one or more actions to take place. It is one of the primary building blocks used for  writing visual novels in Ktvn.</p>"},{"location":"dsl/next/#use","title":"Use","text":"<p>Next can be used for narration.</p> <pre><code>next { narrator narrates \"Although Michel has remained amicable, the witch, Morgana, has not.\" }\n</code></pre> <p>Or a character may speak.</p> <pre><code>next { morgana says \"The two of us are cursed to spend eternity in this mansion.\" }\n</code></pre> <p>Or a character may think.</p> <pre><code>next { morgana thinks \"I could never tell Michel I don't actually think he is a fool.\" }\n</code></pre> <p>Characters can show emotions.</p> <pre><code>next { michel looks concerned }\n</code></pre> <p>Characters can be animated.</p> <pre><code>next { michel begins shaking }\n</code></pre> <p>Change position of a character on the screen.</p> <pre><code>next { layout moveRight morgana }\n</code></pre> <p>Play a sound effect.</p> <pre><code>next { audio sfx sfxFromResource(\"crash\") }\n</code></pre>"},{"location":"dsl/pause/","title":"Pause","text":""},{"location":"dsl/pause/#overview","title":"Overview","text":"<p>Pause is a step that prevents the story from progressing for the specified time.</p>"},{"location":"dsl/pause/#use","title":"Use","text":"<p>The duration of the pause can be specified in seconds.</p> <pre><code>pause {\n    this seconds 5\n}\n</code></pre> <p>For smaller pauses, the duration can be specified in milliseconds.</p> <pre><code>pause {\n    this milliseconds 150\n}\n</code></pre> <p>The pause will be at least the specified duration, but it cannot be guaranteed that it won't be longer so should not be  used for synchronisation purposes.</p>"},{"location":"dsl/then/","title":"Then","text":""},{"location":"dsl/then/#overview","title":"Overview","text":"<p>Then is very similar to next, but allows the step to be named. This is useful if the step needs to be referenced at  some point in the story, for example if the story needs to jump to this step.</p>"},{"location":"dsl/then/#use","title":"Use","text":"<p>The then block can be assigned a name.</p> <pre><code>then {\n    this name \"Michel shows anger\"\n}\n</code></pre> <p>The code that should be executed when the step is invoked can be specified with the does keyword.</p> <pre><code>then {\n    this name \"Michel shows anger\"\n    this does {\n        michel looks angry\n    }\n}\n</code></pre>"}]}